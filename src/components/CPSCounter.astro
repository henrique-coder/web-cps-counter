---
/**
 * CPSCounter - Main CPS tracking component
 * Handles all click/scroll event capture, CPS calculation, and UI updates
 * Uses a 1-second sliding window algorithm for real-time CPS measurement
 */
import CounterCard from "./CounterCard.astro";
import ScrollCard from "./ScrollCard.astro";
import ActionButtons from "./ActionButtons.astro";
import Footer from "./Footer.astro";
---

<main class="app" oncontextmenu="return false">
  <div class="counter-grid">
    <CounterCard id="left" label="Left Click" />
    <div class="center-section">
      <CounterCard id="total" label="Total CPS" size="large" variant="total" />
      <ScrollCard />
    </div>
    <CounterCard id="right" label="Right Click" />
  </div>
  <ActionButtons />
  <Footer />
</main>

<style>
  .app {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    flex: 1;
    padding: 1rem;
    gap: 1.5rem;
    width: 100%;
    max-width: 1200px;
    margin: 0 auto;
  }

  .counter-grid {
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    gap: 1rem;
    width: 100%;
    align-items: stretch;
  }

  .center-section {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    min-width: 280px;
  }

  @media (max-width: 900px) {
    .counter-grid {
      grid-template-columns: 1fr 1fr;
      grid-template-rows: auto auto;
    }

    .center-section {
      grid-column: 1 / -1;
      grid-row: 1;
      flex-direction: row;
      min-width: unset;
    }

    .center-section > :first-child {
      flex: 1.5;
    }

    .center-section > :last-child {
      flex: 1;
    }
  }

  @media (max-width: 600px) {
    .app {
      padding: 0.75rem;
      gap: 0.75rem;
      justify-content: flex-start;
      padding-top: 2rem;
    }

    .counter-grid {
      grid-template-columns: 1fr;
      gap: 0.75rem;
    }

    .center-section {
      flex-direction: column;
      gap: 0.75rem;
    }
  }
</style>

<script>
  // === Configuration ===
  /** Sliding window size in milliseconds for CPS calculation */
  const WINDOW_SIZE = 1000;
  /** localStorage key for persisting max scores */
  const STORAGE_KEY = "cps-counter-max-scores";

  // === Type Definitions ===
  interface ClickWindows {
    left: number[];
    right: number[];
    scroll: number[];
  }

  interface ScrollEvent {
    timestamp: number;
    delta: number;
  }

  interface MaxScores {
    left: number;
    right: number;
    scroll: number;
    total: number;
  }

  // === State ===
  /** Stores timestamps for each click type within the sliding window */
  const clickWindows: ClickWindows = { left: [], right: [], scroll: [] };
  /** Stores recent scroll events for speed calculation (100ms window) */
  const scrollEvents: ScrollEvent[] = [];
  /** Tracks last scroll direction for UI indicator */
  let lastScrollDelta = 0;

  // === LocalStorage Functions ===
  /**
   * Loads max scores from localStorage
   * Returns default scores if not found or parsing fails
   */
  function loadMaxScores(): MaxScores {
    try {
      const stored = localStorage.getItem(STORAGE_KEY);
      if (stored) return JSON.parse(stored);
    } catch {}
    return { left: 0, right: 0, scroll: 0, total: 0 };
  }

  const max = loadMaxScores();

  /** Persists current max scores to localStorage */
  function saveMaxScores() {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(max));
    } catch {}
  }

  /**
   * Updates max score if new value is higher
   * @param type - Score category (left, right, scroll, total)
   * @param value - Current CPS value to compare
   */
  function updateMax(type: keyof MaxScores, value: number) {
    if (value > max[type]) {
      max[type] = parseFloat(value.toFixed(1));
      saveMaxScores();
    }
  }

  // === CPS Calculation ===
  /**
   * Calculates clicks per second using sliding window algorithm
   * Removes expired timestamps (older than WINDOW_SIZE) and returns count
   * @param clicks - Array of click timestamps in milliseconds
   * @returns Number of clicks in the current window
   */
  function calculateCPS(clicks: number[]): number {
    const now = performance.now();
    // Remove expired timestamps from the beginning of the array
    while (clicks.length > 0 && now - clicks[0] > WINDOW_SIZE) {
      clicks.shift();
    }
    return clicks.length;
  }

  /**
   * Calculates scroll speed in pixels per second
   * Uses a 100ms window for smooth speed calculation
   * @returns Scroll speed in px/s
   */
  function calculateScrollSpeed(): number {
    const now = performance.now();
    // Clean up old scroll events (keep only last 100ms)
    while (scrollEvents.length > 0 && now - scrollEvents[0].timestamp > 100) {
      scrollEvents.shift();
    }
    if (scrollEvents.length < 2) return 0;
    // Sum absolute deltas and extrapolate to 1 second
    const totalDelta = scrollEvents.reduce(
      (sum, event) => sum + Math.abs(event.delta),
      0
    );
    return Math.round(totalDelta * (1000 / 100));
  }

  // === Event Handling ===
  /**
   * Checks if an element is interactive (should not count as click)
   * Prevents buttons and links from being counted as CPS clicks
   * @param element - DOM element to check
   * @returns True if element is interactive
   */
  function isInteractiveElement(element: Element | null): boolean {
    if (!element) return false;
    const tag = element.tagName?.toLowerCase();
    if (tag === "button" || tag === "a") return true;
    // Check if element is inside interactive containers
    if ((element as HTMLElement).closest("button, a, .action-buttons, .footer"))
      return true;
    return false;
  }

  /**
   * Handles mouse down events for click tracking
   * Button 0 = left, 1 = middle (scroll), 2 = right
   */
  function handleMouseDown(event: MouseEvent) {
    if (isInteractiveElement(event.target as Element)) return;
    const timestamp = performance.now();
    if (event.button === 0) {
      clickWindows.left.push(timestamp);
    } else if (event.button === 2) {
      clickWindows.right.push(timestamp);
    } else if (event.button === 1) {
      clickWindows.scroll.push(timestamp);
    }
  }

  /** Handles wheel events for scroll tracking */
  function handleWheel(event: WheelEvent) {
    const timestamp = performance.now();
    clickWindows.scroll.push(timestamp);
    scrollEvents.push({ timestamp, delta: event.deltaY });
    lastScrollDelta = event.deltaY;
  }

  // === Display Update ===
  /**
   * Updates all DOM elements with current CPS values
   * Uses requestAnimationFrame for smooth 60fps updates
   */
  function updateDisplay() {
    // Calculate current CPS for each category
    const leftCPS = calculateCPS(clickWindows.left);
    const rightCPS = calculateCPS(clickWindows.right);
    const scrollCPS = calculateCPS(clickWindows.scroll);
    const totalCPS = leftCPS + rightCPS;
    const scrollSpeed = calculateScrollSpeed();

    // Update max scores if current values are higher
    updateMax("left", leftCPS);
    updateMax("right", rightCPS);
    updateMax("scroll", scrollCPS);
    updateMax("total", totalCPS);

    const leftEl = document.getElementById("left-cps");
    const rightEl = document.getElementById("right-cps");
    const totalEl = document.getElementById("total-cps");
    const scrollEl = document.getElementById("scroll-cps");
    const speedEl = document.getElementById("scroll-speed");
    const dirEl = document.getElementById("scroll-direction");

    const leftMaxEl = document.getElementById("left-max");
    const rightMaxEl = document.getElementById("right-max");
    const totalMaxEl = document.getElementById("total-max");
    const scrollMaxEl = document.getElementById("scroll-max");

    if (leftEl) leftEl.textContent = leftCPS.toFixed(1);
    if (rightEl) rightEl.textContent = rightCPS.toFixed(1);
    if (totalEl) totalEl.textContent = totalCPS.toFixed(1);
    if (scrollEl) scrollEl.textContent = scrollCPS.toFixed(1);
    if (speedEl) speedEl.textContent = `${scrollSpeed} px/s`;

    if (leftMaxEl) leftMaxEl.textContent = max.left.toFixed(1);
    if (rightMaxEl) rightMaxEl.textContent = max.right.toFixed(1);
    if (totalMaxEl) totalMaxEl.textContent = max.total.toFixed(1);
    if (scrollMaxEl) scrollMaxEl.textContent = max.scroll.toFixed(1);

    if (dirEl) {
      if (lastScrollDelta > 0) {
        dirEl.textContent = "↓";
        dirEl.className = "scroll-direction down";
      } else if (lastScrollDelta < 0) {
        dirEl.textContent = "↑";
        dirEl.className = "scroll-direction up";
      } else {
        dirEl.textContent = "―";
        dirEl.className = "scroll-direction neutral";
      }
    }

    requestAnimationFrame(updateDisplay);
  }

  /** Resets all max scores to zero */
  function resetMax() {
    max.left = 0;
    max.right = 0;
    max.scroll = 0;
    max.total = 0;
    saveMaxScores();
  }

  // === Screenshot Generation ===
  /**
   * Generates a shareable image using Canvas API
   * Draws a custom card with all max scores and copies to clipboard
   * Falls back to file download if clipboard API is unavailable
   */
  async function captureScreen() {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    // High DPI scaling for crisp images
    const scale = 2;
    const width = 600;
    const height = 360;

    canvas.width = width * scale;
    canvas.height = height * scale;
    ctx.scale(scale, scale);

    // Background gradient
    const gradient = ctx.createLinearGradient(0, 0, width, height);
    gradient.addColorStop(0, "#0f0f0f");
    gradient.addColorStop(1, "#0a0a0a");

    // Draw rounded rectangle background
    const radius = 24;
    ctx.beginPath();
    ctx.moveTo(radius, 0);
    ctx.lineTo(width - radius, 0);
    ctx.quadraticCurveTo(width, 0, width, radius);
    ctx.lineTo(width, height - radius);
    ctx.quadraticCurveTo(width, height, width - radius, height);
    ctx.lineTo(radius, height);
    ctx.quadraticCurveTo(0, height, 0, height - radius);
    ctx.lineTo(0, radius);
    ctx.quadraticCurveTo(0, 0, radius, 0);
    ctx.closePath();
    ctx.fillStyle = gradient;
    ctx.fill();

    ctx.font = "600 24px Inter, system-ui, sans-serif";
    ctx.fillStyle = "#ffffff";
    ctx.textAlign = "center";
    ctx.fillText("CPS Counter", width / 2, 48);

    const accentGradient = ctx.createLinearGradient(
      width / 2 - 60,
      80,
      width / 2 + 60,
      140
    );
    accentGradient.addColorStop(0, "#3b82f6");
    accentGradient.addColorStop(1, "#60a5fa");

    ctx.font = "700 56px Inter, system-ui, sans-serif";
    ctx.fillStyle = accentGradient;
    ctx.fillText(max.total.toFixed(1), width / 2, 115);

    ctx.font = "500 12px Inter, system-ui, sans-serif";
    ctx.fillStyle = "#666666";
    ctx.fillText("BEST TOTAL CPS", width / 2, 140);

    const boxY = 175;
    const boxHeight = 100;
    const boxWidth = 160;
    const gap = 24;
    const startX = (width - (boxWidth * 3 + gap * 2)) / 2;

    const boxes = [
      { label: "LEFT CLICK", value: max.left, color: "#22c55e" },
      { label: "SCROLL", value: max.scroll, color: "#3b82f6" },
      { label: "RIGHT CLICK", value: max.right, color: "#ef4444" },
    ];

    boxes.forEach((box, i) => {
      const x = startX + i * (boxWidth + gap);

      ctx.beginPath();
      const r = 16;
      ctx.moveTo(x + r, boxY);
      ctx.lineTo(x + boxWidth - r, boxY);
      ctx.quadraticCurveTo(x + boxWidth, boxY, x + boxWidth, boxY + r);
      ctx.lineTo(x + boxWidth, boxY + boxHeight - r);
      ctx.quadraticCurveTo(
        x + boxWidth,
        boxY + boxHeight,
        x + boxWidth - r,
        boxY + boxHeight
      );
      ctx.lineTo(x + r, boxY + boxHeight);
      ctx.quadraticCurveTo(x, boxY + boxHeight, x, boxY + boxHeight - r);
      ctx.lineTo(x, boxY + r);
      ctx.quadraticCurveTo(x, boxY, x + r, boxY);
      ctx.closePath();
      ctx.fillStyle = "#161616";
      ctx.fill();

      ctx.strokeStyle = "#222222";
      ctx.lineWidth = 1;
      ctx.stroke();

      ctx.font = "700 32px Inter, system-ui, sans-serif";
      ctx.fillStyle = box.color;
      ctx.textAlign = "center";
      ctx.fillText(box.value.toFixed(1), x + boxWidth / 2, boxY + 45);

      ctx.font = "500 11px Inter, system-ui, sans-serif";
      ctx.fillStyle = "#555555";
      ctx.fillText(box.label, x + boxWidth / 2, boxY + 70);

      ctx.font = "500 10px Inter, system-ui, sans-serif";
      ctx.fillStyle = "#444444";
      ctx.fillText("BEST", x + boxWidth / 2, boxY + 88);
    });

    ctx.font = "500 11px Inter, system-ui, sans-serif";
    ctx.fillStyle = "#444444";
    ctx.textAlign = "center";
    ctx.fillText(
      "github.com/henrique-coder/web-cps-counter",
      width / 2,
      height - 20
    );

    // Convert canvas to blob
    const blob = await new Promise<Blob | null>((resolve) =>
      canvas.toBlob(resolve, "image/png")
    );

    if (!blob) return;

    const captureBtn = document.getElementById("capture-btn");

    // Try clipboard API first, fallback to file download
    try {
      await navigator.clipboard.write([
        new ClipboardItem({ "image/png": blob }),
      ]);
      captureBtn?.classList.add("success");
    } catch {
      // Fallback: trigger file download
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `cps-record-${Date.now()}.png`;
      a.click();
      URL.revokeObjectURL(url);
      captureBtn?.classList.add("success");
    }

    // Reset button state after 2 seconds
    setTimeout(() => {
      captureBtn?.classList.remove("success");
    }, 2000);
  }

  // === Event Listeners ===
  // Passive listeners for better scroll performance
  document.addEventListener("mousedown", handleMouseDown, { passive: true });
  document.addEventListener("wheel", handleWheel, { passive: true });

  // Start the animation loop
  requestAnimationFrame(updateDisplay);

  // Button event bindings
  document.getElementById("capture-btn")?.addEventListener("click", captureScreen);
  document.getElementById("reset-btn")?.addEventListener("click", resetMax);

  // Expose functions globally for potential external access
  (window as any).resetMax = resetMax;
  (window as any).captureScreen = captureScreen;
</script>
